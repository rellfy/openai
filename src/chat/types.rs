use std::fmt::Display;

use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(untagged)]
pub enum Content {
    Str(String),
    Object(Vec<Message>),
}

impl Display for Content {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Content::Str(s) => write!(f, "{}", s),
            Content::Object(m) => write!(f, "{:?}", m),
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum Message {
    Text { text: String },
    ImageUrl { image_url: ImageUrl },
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct ImageUrl {
    url: String,
}

impl Content {
    pub fn new_str(s: &str) -> Content {
        Content::Str(s.to_string())
    }

    pub fn new_object(m: Message) -> Content {
        Content::Object(vec![m])
    }

    pub fn new_text(text: &str) -> Content {
        Content::Object(vec![Message::Text {
            text: text.to_string(),
        }])
    }

    pub fn new_image_url(url: &str) -> Content {
        Content::Object(vec![Message::ImageUrl {
            image_url: ImageUrl {
                url: url.to_string(),
            },
        }])
    }
}

#[macro_export]
macro_rules! new_content {
    ($($json:tt)+) => {{
        use serde_json::Value;
        use $crate::chat::types::Content;
        match serde_json::json!($($json)+) {
            Value::String(s) => Content::new_str(&s),
            Value::Array(a) => serde_json::from_value::<Content>(Value::Array(a)).expect("Failed to parse array as Content"),
            Value::Object(o) => serde_json::from_value(Value::Array(vec![Value::Object(o)])).expect("Failed to parse object as Content"),
            _ => panic!("Invalid Content"),
        }
    }};
}

#[derive(Deserialize, Serialize, Clone, Debug, Eq, PartialEq)]
pub struct ToolCall {
    /// The ID of the tool call.
    pub id: String,
    /// The type of the tool. Currently, only `function` is supported.
    pub r#type: String,
    /// The function that the model called.
    pub function: ToolCallFunction,
}

impl ToolCall {
    pub fn merge(&mut self, other: &ToolCall) {
        if self.id.is_empty() {
            self.id = other.id.clone();
        }
        if self.r#type.is_empty() {
            self.r#type = other.r#type.clone();
        }
        self.function.merge(&other.function);
    }
}

#[derive(Deserialize, Serialize, Clone, Debug, Eq, PartialEq)]
pub struct ToolCallFunction {
    /// The name of the function to call.
    #[serde(default)]
    pub name: String,
    /// The arguments to call the function with, as generated by the model in
    /// JSON format.
    /// Note that the model does not always generate valid JSON, and may
    /// hallucinate parameters not defined by your function schema.
    /// Validate the arguments in your code before calling your function.
    #[serde(default)]
    pub arguments: String,
}

impl ToolCallFunction {
    pub fn merge(&mut self, other: &ToolCallFunction) {
        if self.name.is_empty() {
            self.name = other.name.clone();
        }
        self.arguments.push_str(&other.arguments);
    }
}

#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq)]
pub struct ChatCompletionFunctionCall {
    /// The name of the function ChatGPT called
    pub name: String,
    /// The arguments that ChatGPT called (formatted in JSON)
    /// [API Reference](https://platform.openai.com/docs/api-reference/chat/create#chat/create-function_call)
    pub arguments: String,
}

/// Same as ChatCompletionFunctionCall, but received during a response stream.
#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq)]
pub struct ChatCompletionFunctionCallDelta {
    /// The name of the function ChatGPT called
    pub name: Option<String>,
    /// The arguments that ChatGPT called (formatted in JSON)
    /// [API Reference](https://platform.openai.com/docs/api-reference/chat/create#chat/create-function_call)
    pub arguments: Option<String>,
}

impl From<ChatCompletionFunctionCallDelta> for ChatCompletionFunctionCall {
    fn from(delta: ChatCompletionFunctionCallDelta) -> Self {
        ChatCompletionFunctionCall {
            name: delta.name.unwrap_or("".to_string()),
            arguments: delta.arguments.unwrap_or_default(),
        }
    }
}

#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ChatCompletionToolDefinition {
    Function {
        function: ChatCompletionFunctionDefinition,
    },
}

#[derive(Deserialize, Serialize, Debug, Clone, Eq, PartialEq)]
pub struct ChatCompletionFunctionDefinition {
    /// The name of the function
    pub name: String,
    /// The description of the function
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The parameters of the function formatted in JSON Schema
    /// [API Reference](https://platform.openai.com/docs/api-reference/chat/create#chat/create-parameters)
    /// [See more information about JSON Schema.](https://json-schema.org/understanding-json-schema/)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<Value>,
}

#[derive(Serialize, Debug, Clone, Eq, PartialEq)]
pub struct ChatCompletionResponseFormat {
    /// Must be one of text or json_object (defaults to text)
    #[serde(rename = "type")]
    typ: String,
}

impl ChatCompletionResponseFormat {
    pub fn json_object() -> Self {
        ChatCompletionResponseFormat {
            typ: "json_object".to_string(),
        }
    }

    pub fn text() -> Self {
        ChatCompletionResponseFormat {
            typ: "text".to_string(),
        }
    }
}

#[derive(Serialize, Debug, Clone, Eq, PartialEq)]
pub struct VeniceParameters {
    pub include_venice_system_prompt: bool,
}
