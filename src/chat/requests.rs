use super::{modules::*, types::*, ToolChoiceMode};
use crate::{openai_get_with_query, ApiResponseOrError, Credentials, RequestPagination};
use derive_builder::Builder;
use reqwest_eventsource::CannotCloneRequestError;
use serde::Serialize;
use serde_json::Value;
use std::collections::HashMap;
use tokio::sync::mpsc::Receiver;

#[derive(Serialize, Builder, Debug, Clone)]
#[builder(derive(Clone, Debug, PartialEq))]
#[builder(pattern = "owned")]
#[builder(name = "ChatCompletionBuilder")]
#[builder(setter(strip_option, into))]
pub struct ChatCompletionRequest {
    /// ID of the model to use. Currently, only `gpt-3.5-turbo`, `gpt-3.5-turbo-0301` and `gpt-4`
    /// are supported.
    model: String,
    /// The messages to generate chat completions for, in the [chat format](https://platform.openai.com/docs/guides/chat/introduction).
    messages: Vec<ChatCompletionMessage>,
    /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
    ///
    /// We generally recommend altering this or `top_p` but not both.
    #[builder(default)]
    #[serde(skip_serializing_if = "Option::is_none")]
    temperature: Option<f32>,
    /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
    ///
    /// We generally recommend altering this or `temperature` but not both.
    #[builder(default)]
    #[serde(skip_serializing_if = "Option::is_none")]
    top_p: Option<f32>,
    /// How many chat completion choices to generate for each input message.
    #[builder(default)]
    #[serde(skip_serializing_if = "Option::is_none")]
    n: Option<u8>,
    #[builder(default)]
    #[serde(skip_serializing_if = "Option::is_none")]
    stream: Option<bool>,
    /// Up to 4 sequences where the API will stop generating further tokens.
    #[builder(default)]
    #[serde(skip_serializing_if = "Vec::is_empty")]
    stop: Vec<String>,
    /// This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result. Determinism is not guaranteed, and you should refer to the system_fingerprint response parameter to monitor changes in the backend.
    #[builder(default)]
    #[serde(skip_serializing_if = "Option::is_none")]
    seed: Option<u64>,
    /// The maximum number of tokens allowed for the generated answer. By default, the number of tokens the model can return will be (4096 - prompt tokens).
    #[builder(default)]
    #[serde(skip_serializing_if = "Option::is_none")]
    max_tokens: Option<u64>,
    /// The maximum number of tokens allowed for the generated answer.
    /// For reasoning models such as o1 and o3-mini, this does not include reasoning tokens.
    #[builder(default)]
    #[serde(skip_serializing_if = "Option::is_none")]
    max_completion_tokens: Option<u64>,
    /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
    ///
    /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/api-reference/parameter-details)
    #[builder(default)]
    #[serde(skip_serializing_if = "Option::is_none")]
    presence_penalty: Option<f32>,
    /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
    ///
    /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/api-reference/parameter-details)
    #[builder(default)]
    #[serde(skip_serializing_if = "Option::is_none")]
    frequency_penalty: Option<f32>,
    /// Modify the likelihood of specified tokens appearing in the completion.
    ///
    /// Accepts a json object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
    #[builder(default)]
    #[serde(skip_serializing_if = "Option::is_none")]
    logit_bias: Option<HashMap<String, f32>>,
    /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
    #[builder(default)]
    #[serde(skip_serializing_if = "String::is_empty")]
    user: String,
    /// A list of tools the model may call during execution.
    /// Currently, only function-based tools (`ChatCompletionToolDefinition::Function`) are supported.
    ///
    /// When tools are provided, the model can choose to call them using the behavior specified by `tool_choice`.
    /// If no tools are provided, `tool_choice` defaults to `None`, and the model will not call any tools.
    ///
    /// [API Reference](https://platform.openai.com/docs/api-reference/chat/create#chat-create-tools)
    #[builder(default)]
    #[serde(skip_serializing_if = "Vec::is_empty")]
    tools: Vec<ChatCompletionToolDefinition>,
    /// Controls how the model responds to tool calls.
    ///
    /// - "none" means the model will not call any tools and will respond directly to the user.
    /// - "auto" means the model can choose between responding directly or calling one or more tools.
    /// - "required" means the model must call at least one tool.
    ///
    /// The default is "none" when no tools are provided, and "auto" when tools are available.
    /// [API Reference](https://platform.openai.com/docs/api-reference/chat/create#chat-create-tool_choice)
    #[builder(default)]
    #[serde(skip_serializing_if = "Option::is_none")]
    tool_choice: Option<ToolChoiceMode>,
    /// Describe functions that ChatGPT can call
    /// The latest models of ChatGPT support function calling, which allows you to define functions that can be called from the prompt.
    /// For example, you can define a function called "get_weather" that returns the weather in a given city
    ///
    /// [Function calling API Reference](https://platform.openai.com/docs/api-reference/chat/create#chat/create-functions)
    /// [See more information about function calling in ChatGPT.](https://platform.openai.com/docs/guides/gpt/function-calling)
    #[deprecated(note = "Use tools instead")]
    #[builder(default)]
    #[serde(skip_serializing_if = "Vec::is_empty")]
    functions: Vec<ChatCompletionFunctionDefinition>,
    /// A string or object of the function to call
    ///
    /// Controls how the model responds to function calls
    ///
    /// - "none" means the model does not call a function, and responds to the end-user.
    /// - "auto" means the model can pick between an end-user or calling a function.
    /// - Specifying a particular function via {"name":\ "my_function"} forces the model to call that function.
    ///
    /// "none" is the default when no functions are present. "auto" is the default if functions are present.
    #[deprecated(note = "Use tool_choice instead")]
    #[builder(default)]
    #[serde(skip_serializing_if = "Option::is_none")]
    function_call: Option<Value>,
    /// An object specifying the format that the model must output. Compatible with GPT-4 Turbo and all GPT-3.5 Turbo models newer than gpt-3.5-turbo-1106.
    /// Setting to { "type": "json_object" } enables JSON mode, which guarantees the message the model generates is valid JSON.
    /// Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
    #[builder(default)]
    #[serde(skip_serializing_if = "Option::is_none")]
    response_format: Option<ChatCompletionResponseFormat>,
    /// The credentials to use for this request.
    #[serde(skip_serializing)]
    #[builder(default)]
    pub credentials: Option<Credentials>,
    /// Parameters unique to the Venice API.
    /// https://docs.venice.ai/api-reference/api-spec
    #[builder(default)]
    #[serde(skip_serializing_if = "Option::is_none")]
    venice_parameters: Option<VeniceParameters>,
    /// Whether to store the completion for use in distillation or evals.
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub store: Option<bool>,
}

impl ChatCompletionBuilder {
    pub async fn create(self) -> ApiResponseOrError<ChatCompletion> {
        ChatCompletion::create(self.build().unwrap()).await
    }

    pub async fn create_stream(
        mut self,
    ) -> Result<Receiver<ChatCompletionDelta>, CannotCloneRequestError> {
        self.stream = Some(Some(true));
        ChatCompletionDelta::create(self.build().unwrap()).await
    }
}

impl<C> ChatCompletionGeneric<C> {
    pub fn builder(
        model: &str,
        messages: impl Into<Vec<ChatCompletionMessage>>,
    ) -> ChatCompletionBuilder {
        ChatCompletionBuilder::create_empty()
            .model(model)
            .messages(messages)
    }
}

#[derive(Serialize, Builder, Debug, Clone, Default)]
#[builder(derive(Clone, Debug, PartialEq))]
#[builder(pattern = "owned")]
#[builder(name = "ChatCompletionMessagesRequestBuilder")]
#[builder(setter(strip_option, into))]
pub struct ChatCompletionMessagesRequest {
    #[serde(skip_serializing)]
    pub completion_id: String,

    #[builder(default)]
    #[serde(skip_serializing)]
    pub credentials: Option<Credentials>,

    #[builder(default)]
    #[serde(flatten)]
    pub pagination: RequestPagination,
}

impl ChatCompletionMessages {
    /// Create a builder for fetching messages for a stored completion.
    pub fn builder(completion_id: String) -> ChatCompletionMessagesRequestBuilder {
        ChatCompletionMessagesRequestBuilder::create_empty()
            .completion_id(completion_id.to_string())
    }

    /// Fetch messages for a stored completion.
    pub async fn fetch(
        request: ChatCompletionMessagesRequest,
    ) -> ApiResponseOrError<ChatCompletionMessages> {
        let route = format!("chat/completions/{}/messages", request.completion_id);
        let credentials = request.credentials.clone();
        openai_get_with_query(route.as_str(), &request, credentials).await
    }
}

impl ChatCompletionMessagesRequestBuilder {
    /// Fetch messages for the specified completion.
    pub async fn fetch(self) -> ApiResponseOrError<ChatCompletionMessages> {
        ChatCompletionMessages::fetch(self.build().unwrap()).await
    }
}
